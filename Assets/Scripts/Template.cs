//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
/*using System;
using UnityEngine;

namespace AssemblyCSharp
{
    //MonoBehaviour is the base class that every script derives from
    //has a bunch of stuff like update(), onCollision2D(), destroy(), etc 
    public class Template : MonoBehaviour
    {
        public Player player;
        // public float AgroRange;
		
        // private EnemyMoveController moveController;
        // private Health health;
		
        System.Random rnd;	
		
   	    private bool isAgro;
        private float currentX, currentY, xDirection, yDirection;
        private Transform playerPos;
        private Vector2 distance, speed;
        private double t;
        //private Rigidbody2D rigidbody
		
        //private Animator animator;
		
		
        public void Start()
        {
            //animator = GetComponent<Animator>();
            //  moveController = GetComponent<EnemyMoveController>();
            //  health = GetComponent<Health>();
			
            //rigidbody = getComponent<Rigidbody2D>();
			
            isAgro = false;
            t = 3;
            //Assigning default values like null and 0 to variables is a good idea here, but I'm too lazy
        }
		
        public void Update()
        {
            //creating a random seed that we will use later
            //this just makes random pretty much reset itself after every call, in simple terms. Otherwise, our random number will not change and therefore not be random
            rnd = new System.Random();
			
            //transform is the enemy that this script is attached to, and is a unity keyword. 
            //the position is a variable in transform that is stored in a vector2, or a vector with an x and a y 
            //(it's just a position, the vector doesn't have a speed or anything)
            currentX = transform.position.x;
            currentY = transform.position.y;
 
            //when calling transform on other objects, you must specify
            playerPos = player.transform;
			
            //distance is a vector2, so it holds both an x and a y
            distance = playerPos.position - transform.position;
            
            //distance.magnitude is just the magnitude of the vector, or the sqrt of x^2 + y^2 
            //so it is the length from the player to the enemy in whatever units
            if (distance.magnitude <= AgroRange)
            {
                isAgro = true;
				
            }
            if (distance.magnitude > AgroRange)
            {
                isAgro = false;
            }
			
			
            //show how projectiles work later
            //things that you don't think are projectiles could be projectiles if you believe hard enough
            //for example, an area could be exploding, which would be a timed projectile that didn't move						
			
            if (isAgro)
            {
                //changing currentX and currentY will not do anything
				
                xDirection = playerPos.position.x - currentX;
                yDirection = playerPos.position.y - currentY;
                //place enemy slightly closer to player every frame.
                transform.position.x += xDirection/25;
                transform.position.y += yDirection/25;
				
				
                //This works, but is impractical and jittery, luckily unity has it's own system for moving
				
				
                //GetComponent<Rigidbody2D>().velocity;
                //rigidbody.velocity = new Vector2(xDirection/25, yDirection/25);
                //gives the enemy a velocity in that direction
                //works and is good, but we have our own class that uses rigidbody and is a bit more flexible
                //enemyMoveController! (and there's one for the player, don't worry)
				 
				
				
                //moveController.Move(xDirection / 6, yDirection / 6);
                //these numbers are just sample numbers, they are tweaked to create faster or slower enemies in the real code
                //there are also many interactions you can create by putting in if statements checking range, cooldowns, or whatever and making the enemy react differently 
				
            }
			
			
			
            //if the enemy is not fighting a player, it usually just idles and walks around
            else
            {
                //we will use t as a limiter so the enemy pauses in between walking around. t is in seconds.
                if (t < 1)
                {
                    //If the enemy is idly moving, stop it (so it doesn't go too far or moves for too long)
                    if (rigidbody.magnitude != 0)
                    {
                        //using Rigidbody2D, you would create a speed vector and then in the end assign it to the rigidbody velocity
                        //speed = new Vector2 (0, 0);
						
                        //we can just use move
                        moveController.Move(0, 0);
                        //let's set the limiter to 3 so the enemy can move again
                        t = 3;
                    }
                }
                //One second after the reset, the enemy will move (3-1 = 2 seconds)
                else if (t < 2 && t > 1.3)
                {
					
                    //using our random seed, we can create random numbers, which we store in rand.
                    //rnd.Next(1,5) means that random will select a random number from 1 to 4, so from the minimum to the maximum - 1
                    int rand = rnd.Next(1, 5);
					
                    if (rand == 1)    
                    {   
                        //This .Move() is different, because we are using constants. We cannot create decimals since float can't be put into a double, so we either have to cast one of the numbers
                        //to a float or we can use this different method in moveController. Instead of making the enemy move with a speed of (a,b) it will move with a speed of (a/c,b/c), where c
                        //the third variable in move (pretty much it's (a,b,c), and the movement vector becomes (a/c,b/c)). This lets us have movements that flow better/are less jerky
                        moveController.Move(1, 0, 5);
                        t = 1.3;    
                    }
					
                    else if (rand == 2)    
                    {
                        moveController.Move(-1, 0, 5);
                        t = 1.3;   
                    }
					
                    else if (rand == 3)    
                    {
                        moveController.Move(0, 1, 5);
                        t = 1.3;
						
                    }
					
                    else  
                    {
                        moveController.Move(0, -1, 5);
                        t = 1.3;
						
                    }
					
                }
                //here, we're substracting time by the amount of time it took to perform this update, or one frame, in seconds. 
                //so for every 1 millisecond or however long the frame took, it will reduce 1 millisecond from t   
                t -= Time.deltaTime;
				
                //If we didn't have the enemyMoveController, this is where we would set speed, instead of setting it multiple times in the code    
                //GetComponent<Rigidbody2D> ().velocity = speed;
				
                //In the actual code, it is not neat like this but very messy, with occassional mistakes like setting the velocity multiple times instead of once
                //I'm sorry for this, but I was using MonoDevelop and it annoys me, so I just try to get it over quickly
                //MonoDevelop also auto formats in wierd ways, so be careful if you use it (try putting a ; after an if statement, see what happens)
                //Don't hate me :(
            }
			
			
        }
		
        //this is a simple get method for getting agro, if you wanna check somewhere else whether this enemy is agro'd
        public bool getAgro()
        {        
            return isAgro;
			
        }
		
        //This one instead returns a value taken from the health class
        public int currentHp()
        {
			
            return health.currentHealth;
			
        }
		
        //Here is what every character should have, a death animation that can be called 
        public void onDeath()     
        {
            //play death animation
			
        }
		
    }
	
}*/
