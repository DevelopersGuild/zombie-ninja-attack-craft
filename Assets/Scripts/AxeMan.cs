//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace AssemblyCSharp
{
    public class AxeMan : MonoBehaviour
    {
        public Player player;
        public float AgroRange;
        //public Axe ax, axeObject;

        private EnemyMoveController moveController;
        private Health health;

        private bool isAgro;

        System.Random rnd;

        private Vector2 distance, speed, facing;
        private double t, temp;

        //private Animator animator;


        public void Start()
        {
            //animator = GetComponent<Animator>();
            moveController = GetComponent<EnemyMoveController>();
            health = GetComponent<Health>();
            //rigidbody2D.mass = 10;
            distance = new Vector2(0, 0);
            speed = new Vector2(0, 0);
            isAgro = false;
            t = 3;
            //temp is the number for exponential speed when running away
            temp = 1.0000001;

            facing = new Vector2(0, 0);

        }

        public void Update()
        {
            rnd = new System.Random();
            if (player != null)
            {
                //basic aggression range formula
                distance = player.transform.position - transform.position;
                if (distance.magnitude <= AgroRange)
                {
                    isAgro = true;
                    //animator.SetBool("isCharging", true);
                }
                if (distance.magnitude > AgroRange)
                {
                    isAgro = false;
                }

                if (isAgro)
                {
                    //Axe ax = Instantiate(axeObject, transform.position, transform.rotation) as Axe;
                    float xSp = player.transform.position.x - transform.position.x;
                    float ySp = player.transform.position.y - transform.position.y;
                    //exponential speed
                    /*if (distance.magnitude < 1.5) {
                            xSp *= -temp;
                            ySp *= -temp;
                            temp *= 1.2;
												
                    } else if (distance.magnitude < 2) {
                            xSp = 0;
                            ySp = 0;
                            //temp = 0;
                    }
                    else {
                            temp = 0.5;
                    }
                    speed = new Vector2 ((float)xSp, (float)ySp);
                    //Debug.Log ("Que es x and y? : " + xSp + " and " + ySp);
                    speed = speed.normalized;*/
                    moveController.Move(xSp / 15f, ySp / 15f);
                    Debug.Log("I'm moving at a speed of " + xSp + " and " + ySp);
                    if (distance.magnitude < 1.1)
                    {
                        moveController.Move(-xSp / 10f, -ySp / 10f);
                        Debug.Log("I'm running away at a speed of " + xSp + " and " + ySp);
                    }

                }
                else
                {
                    //Debug.Log ("is");
                    if (t < 1)
                    {
                        if (GetComponent<Rigidbody2D>().velocity.magnitude != 0)
                        {
                            //speed = new Vector2 (0, 0);
                            moveController.Move(0, 0);
                            t = 3;
                        }
                    }
                    else if (t < 2 && t > 1.3)
                    {
                        float d = 1;
                        int rand = rnd.Next(1, 5);
                        if (rand == 1)
                        {
                            //speed = new Vector2 (2, 0);
                            moveController.Move(d, 0, 5);

                            t = 1.3;
                        }
                        else if (rand == 2)
                        {
                            //speed = new Vector2 (-2, 0);
                            moveController.Move(-d, 0, 5);
                            t = 1.3;
                        }
                        else if (rand == 3)
                        {
                            //speed = new Vector2 (0, 2);
                            moveController.Move(0, d, 5);
                            t = 1.3;
                        }
                        else
                        {
                            //speed = new Vector2 (0, -2);
                            moveController.Move(0, -d, 5);
                            t = 1.3;
                        }

                    }
                    t -= Time.deltaTime;
                    //GetComponent<Rigidbody2D> ().velocity = speed;

                }
                //Debug.Log (t);
                //GetComponent<Rigidbody2D> ().velocity = speed;
                //Debug.Log (rigidbody2D.velocity.magnitude);
            }
        }

        public Vector2 getIdle()
        {
            // facing = moveController.getFacing ();
            float thisX = transform.position.x;
            float thisY = transform.position.y;
            if (facing.x == 1)
            {
                return new Vector2(thisX - 1, thisY - 1);
            }
            else if (facing.x == -1)
            {
                return new Vector2(thisX + 1, thisY - 1);
            }
            else if (facing.y == 1)
            {
                return new Vector2(thisX + 1, thisY - 1);
            }
            else if (facing.y == -1)
            {
                return new Vector2(thisX - 1, thisY + 1);
            }
            return new Vector2(0, 0);
        }

        public bool getAgro()
        {
            return isAgro;
        }

        public int currentHp()
        {
            return health.currentHealth;
        }


    }
}

