//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;

public class ChargerAI : MonoBehaviour {
	//Positions
	public Player player;
	public float AgroRange;
	public EnemyMoveController moveController;

	private Vector2 speed, distance;

    //State checks
	private bool isAggroed;
    private bool isTired;
    private bool isCharging;

    //Components
	private Animator animator;
    //private MoveControllerNoAnimation moveControllerNoAnimation;
	
	System.Random rnd;
	private double t, timer;
	private float temp;
	
	public void Start() {
  		//moveControllerNoAnimation = GetComponent<MoveControllerNoAnimation> ();
        animator = GetComponent<Animator>();
		moveController = GetComponent<EnemyMoveController> ();

		distance = new Vector2 (0, 0);
		speed = new Vector2 (0, 0);

		temp = 0;
		t = 1;
		timer = 5;

		isAggroed = false;
        isTired = false;
        isCharging = false;
		GetComponent<Rigidbody2D>().mass = 5;
	}

	void Update() {
				rnd = new System.Random ();

				//Nir, this isnt necessary. You can get the position of the object the script is attached to by
				//transform.position because it assumes that it's its own transform if its not stated. thx bb delete this
				//enemyPosition = Enemy.position; WRONG
				//transform.position; woooo
				distance = player.transform.position - transform.position;
		

				//Check distance between the player and charger. If its close enough, aggro
				if (distance.magnitude <= AgroRange && isTired == false) {
			Debug.Log ("Test Point 1");
						isAggroed = true;
						isCharging = true;
						animator.SetBool ("isCharging", true);
				}
				if (distance.magnitude > AgroRange) {
						isAggroed = false;
				}
				// speed = new Vector2(0, 0);

				if (isAggroed) {

						//Charge while the charge animation is playing
						if (isCharging) {
				Debug.Log ("Test Point 2");
								float xSpeed = player.transform.position.x - transform.position.x;
								float ySpeed = player.transform.position.y - transform.position.y;
								RunStraight (xSpeed, ySpeed, temp);
								temp = 5;
								//speed = new Vector2(5 * xSpeed, 5 * ySpeed);
								//speed = speed * 3;
						}
						//Dont move if charger has already charged and is now tired
						if (isTired) {
				Debug.Log ("Test Point 3");
								temp = 1;
								moveController.Move (0, 0);
						}
				} //If the player isnt aggroed, it moves randomly
        		else {
					if (t < 1) {
						if (moveController.getMove () != 0) {
										//speed = new Vector2 (0, 0);
										moveController.Move (0, 0);
										t = 3;
								}
						} else if (t < 3 && t > 1.3) {
								Debug.Log ("it happening?");
								int rand = rnd.Next (1, 5);
								if (rand == 1) {
										//speed = new Vector2 (2, 0);
										moveController.Move (1, 0);
										t = 1.3;
								} else if (rand == 2) {
										//speed = new Vector2 (-2, 0);
										moveController.Move (-1, 0);
										t = 1.3;
								} else if (rand == 3) {
										//speed = new Vector2 (0, 2);
										moveController.Move (0, 1);
										t = 1.3;
								} else {
										//speed = new Vector2 (0, -2);
										moveController.Move (0, -1);							
										t = 1.3;
								}
						}
						//Debug.Log(isCharging);
						temp -= Time.deltaTime;
						t -= Time.deltaTime;
				}
		}

    public void DoneCharging() {
        isTired = true;
        animator.SetBool("isCharging", false);
        animator.SetBool("isTired", true);
    }

    public void DoneResting() {
        isTired = false;
        animator.SetBool("isTired", false);
    }

	private void RunStraight(float xSp,float ySp,float extra) {
		if(extra == 1) {
			//speed = new Vector2(xSp, ySp);
			//speed = 2 * speed;
			moveController.Move (xSp/4,ySp/4);
		}

	}
}
	

